# 1 "/home/lchampagne/Documents/Test/int_v1.0/int.p4"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/home/lchampagne/Documents/Test/int_v1.0/int.p4"
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Damian Parniewicz, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/////////////////////////////////////////////////////////////////////////////////////////////////////////

# 1 "/usr/local/share/p4c/p4include/core.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This is the P4-16 core library, which declares some built-in P4 constructs using P4 */




/// Standard error codes.  New error codes can be declared by users.
error {
    NoError, /// No error.
    PacketTooShort, /// Not enough bits in packet for 'extract'.
    NoMatch, /// 'select' expression has no matches.
    StackOutOfBounds, /// Reference to invalid element of a header stack.
    HeaderTooShort, /// Extracting too many bits into a varbit field.
    ParserTimeout, /// Parser execution time limit exceeded.
    ParserInvalidArgument /// Parser operation was called with a value
                           /// not supported by the implementation.
}

extern packet_in {
    /// Read a header from the packet into a fixed-sized header @hdr and advance the cursor.
    /// May trigger error PacketTooShort or StackOutOfBounds.
    /// @T must be a fixed-size header type
    void extract<T>(out T hdr);
    /// Read bits from the packet into a variable-sized header @variableSizeHeader
    /// and advance the cursor.
    /// @T must be a header containing exactly 1 varbit field.
    /// May trigger errors PacketTooShort, StackOutOfBounds, or HeaderTooShort.
    void extract<T>(out T variableSizeHeader,
                    in bit<32> variableFieldSizeInBits);
    /// Read bits from the packet without advancing the cursor.
    /// @returns: the bits read from the packet.
    /// T may be an arbitrary fixed-size type.
    T lookahead<T>();
    /// Advance the packet cursor by the specified number of bits.
    void advance(in bit<32> sizeInBits);
    /// @return packet length in bytes.  This method may be unavailable on
    /// some target architectures.
    bit<32> length();
}

extern packet_out {
    /// Write @hdr into the output packet, advancing cursor.
    /// @T can be a header type, a header stack, a header_union, or a struct
    /// containing fields with such types.
    void emit<T>(in T hdr);
}

// TODO: remove from this file, convert to built-in
/// Check a predicate @check in the parser; if the predicate is true do nothing,
/// otherwise set the parser error to @toSignal, and transition to the `reject` state.
extern void verify(in bool check, in error toSignal);

/// Built-in action that does nothing.
@noWarn("unused")
action NoAction() {}

/// Standard match kinds for table key fields.
/// Some architectures may not support all these match kinds.
/// Architectures can declare additional match kinds.
match_kind {
    /// Match bits exactly.
    exact,
    /// Ternary match, using a mask.
    ternary,
    /// Longest-prefix match.
    lpm
}
# 24 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/usr/local/share/p4c/p4include/v1model.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* P4-16 declaration of the P4 v1.0 switch model */

/* Note 1: More details about the definition of v1model architecture
 * can be found at the location below.
 *
 * https://github.com/p4lang/behavioral-model/blob/master/docs/simple_switch.md
 *
 * Note 2: There were several discussions among P4 working group
 * members in early 2019 regarding exactly how resubmit, recirculate,
 * and clone3 operations can be called anywhere in their respective
 * controls, but the values of the fields to be preserved is the value
 * they have when that control is finished executing.  That is how
 * these operations are defined in P4_14.  See
 * https://github.com/p4lang/behavioral-model/blob/master/docs/simple_switch.md#restrictions-on-recirculate-resubmit-and-clone-operations
 * for more details on the current state of affairs.
 *
 * Note 3: There are at least some P4_14 implementations where
 * invoking a generate_digest operation on a field_list will create a
 * message to the control plane that contains the values of those
 * fields when the ingress control is finished executing, which can be
 * different than the values those fields have at the time the
 * generate_digest operation is invoked in the program, if those field
 * values are changed later in the execution of the P4_14 ingress
 * control.
 *
 * The P4_16 plus v1model implementation should always create digest
 * messages that contain the values of the specified fields at the
 * time that the digest extern function is called.  Thus if a P4_14
 * program expecting the behavior described above is compiled using
 * p4c, it may behave differently.
 */




# 1 "/usr/local/share/p4c/p4include/core.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This is the P4-16 core library, which declares some built-in P4 constructs using P4 */
# 53 "/usr/local/share/p4c/p4include/v1model.p4" 2





match_kind {
    range,
    // Either an exact match, or a wildcard (matching any value).
    optional,
    // Used for implementing dynamic_action_selection
    selector
}

const bit<32> __v1model_version = 20180101;





@metadata @name("standard_metadata")
struct standard_metadata_t {





    bit<9> ingress_port;
    bit<9> egress_spec;
    bit<9> egress_port;

    bit<32> instance_type;
    bit<32> packet_length;
    //
    // @alias is used to generate the field_alias section of the BMV2 JSON.
    // Field alias creates a mapping from the metadata name in P4 program to
    // the behavioral model's internal metadata name. Here we use it to
    // expose all metadata supported by simple switch to the user through
    // standard_metadata_t.
    //
    // flattening fields that exist in bmv2-ss
    // queueing metadata
    @alias("queueing_metadata.enq_timestamp")
    bit<32> enq_timestamp;
    @alias("queueing_metadata.enq_qdepth")
    bit<19> enq_qdepth;
    @alias("queueing_metadata.deq_timedelta")
    bit<32> deq_timedelta;
    /// queue depth at the packet dequeue time.
    @alias("queueing_metadata.deq_qdepth")
    bit<19> deq_qdepth;

    // intrinsic metadata
    @alias("intrinsic_metadata.ingress_global_timestamp")
    bit<48> ingress_global_timestamp;
    @alias("intrinsic_metadata.egress_global_timestamp")
    bit<48> egress_global_timestamp;
    /// multicast group id (key for the mcast replication table)
    @alias("intrinsic_metadata.mcast_grp")
    bit<16> mcast_grp;
    /// Replication ID for multicast
    @alias("intrinsic_metadata.egress_rid")
    bit<16> egress_rid;
    /// Indicates that a verify_checksum() method has failed.
    /// 1 if a checksum error was found, otherwise 0.
    bit<1> checksum_error;
    /// Error produced by parsing
    error parser_error;
    /// set packet priority
    @alias("intrinsic_metadata.priority")
    bit<3> priority;
}

enum CounterType {
    packets,
    bytes,
    packets_and_bytes
}

enum MeterType {
    packets,
    bytes
}

extern counter



{
    /***
     * A counter object is created by calling its constructor.  This
     * creates an array of counter states, with the number of counter
     * states specified by the size parameter.  The array indices are
     * in the range [0, size-1].
     *
     * You must provide a choice of whether to maintain only a packet
     * count (CounterType.packets), only a byte count
     * (CounterType.bytes), or both (CounterType.packets_and_bytes).
     *
     * Counters can be updated from your P4 program, but can only be
     * read from the control plane.  If you need something that can be
     * both read and written from the P4 program, consider using a
     * register.
     */
    counter(bit<32> size, CounterType type);
    // FIXME -- size arg should be `int` but that breaks typechecking

    /***
     * count() causes the counter state with the specified index to be
     * read, modified, and written back, atomically relative to the
     * processing of other packets, updating the packet count, byte
     * count, or both, depending upon the CounterType of the counter
     * instance used when it was constructed.
     *
     * @param index The index of the counter state in the array to be
     *              updated, normally a value in the range [0,
     *              size-1].  If index >= size, no counter state will be
     *              updated.
     */



    void count(in bit<32> index);

}

extern direct_counter {
    /***
     * A direct_counter object is created by calling its constructor.
     * You must provide a choice of whether to maintain only a packet
     * count (CounterType.packets), only a byte count
     * (CounterType.bytes), or both (CounterType.packets_and_bytes).
     * After constructing the object, you can associate it with at
     * most one table, by adding the following table property to the
     * definition of that table:
     *
     *     counters = <object_name>;
     *
     * Counters can be updated from your P4 program, but can only be
     * read from the control plane.  If you need something that can be
     * both read and written from the P4 program, consider using a
     * register.
     */
    direct_counter(CounterType type);
    /***
     * The count() method is actually unnecessary in the v1model
     * architecture.  This is because after a direct_counter object
     * has been associated with a table as described in the
     * documentation for the direct_counter constructor, every time
     * the table is applied and a table entry is matched, the counter
     * state associated with the matching entry is read, modified, and
     * written back, atomically relative to the processing of other
     * packets, regardless of whether the count() method is called in
     * the body of that action.
     */
    void count();
}





extern meter



{
    /***
     * A meter object is created by calling its constructor.  This
     * creates an array of meter states, with the number of meter
     * states specified by the size parameter.  The array indices are
     * in the range [0, size-1].  For example, if in your system you
     * have 128 different "flows" numbered from 0 up to 127, and you
     * want to meter each of those flows independently of each other,
     * you could do so by creating a meter object with size=128.
     *
     * You must provide a choice of whether to meter based on the
     * number of packets, regardless of their size
     * (MeterType.packets), or based upon the number of bytes the
     * packets contain (MeterType.bytes).
     */
    meter(bit<32> size, MeterType type);
    // FIXME -- size arg should be `int` but that breaks typechecking

    /***
     * execute_meter() causes the meter state with the specified index
     * to be read, modified, and written back, atomically relative to
     * the processing of other packets, and an integer encoding of one
     * of the colors green, yellow, or red to be written to the result
     * out parameter.
     *
     * @param index The index of the meter state in the array to be
     *              updated, normally a value in the range [0,
     *              size-1].  If index >= size, no meter state will be
     *              updated.
     * @param result Type T must be bit<W> with W >= 2.  When index is
     *              in range, the value of result will be assigned 0
     *              for color GREEN, 1 for color YELLOW, and 2 for
     *              color RED (see RFC 2697 and RFC 2698 for the
     *              meaning of these colors).  When index is out of
     *              range, the final value of result is not specified,
     *              and should be ignored by the caller.
     */



    void execute_meter<T>(in bit<32> index, out T result);

}

extern direct_meter<T> {
    /***
     * A direct_meter object is created by calling its constructor.
     * You must provide a choice of whether to meter based on the
     * number of packets, regardless of their size
     * (MeterType.packets), or based upon the number of bytes the
     * packets contain (MeterType.bytes).  After constructing the
     * object, you can associate it with at most one table, by adding
     * the following table property to the definition of that table:
     *
     *     meters = <object_name>;
     */
    direct_meter(MeterType type);
    /***
     * After a direct_meter object has been associated with a table as
     * described in the documentation for the direct_meter
     * constructor, every time the table is applied and a table entry
     * is matched, the meter state associated with the matching entry
     * is read, modified, and written back, atomically relative to the
     * processing of other packets, regardless of whether the read()
     * method is called in the body of that action.
     *
     * read() may only be called within an action executed as a result
     * of matching a table entry, of a table that has a direct_meter
     * associated with it.  Calling read() causes an integer encoding
     * of one of the colors green, yellow, or red to be written to the
     * result out parameter.
     *
     * @param result Type T must be bit<W> with W >= 2.  The value of
     *              result will be assigned 0 for color GREEN, 1 for
     *              color YELLOW, and 2 for color RED (see RFC 2697
     *              and RFC 2698 for the meaning of these colors).
     */
    void read(out T result);
}




extern register<T>

{
    /***
     * A register object is created by calling its constructor.  This
     * creates an array of 'size' identical elements, each with type
     * T.  The array indices are in the range [0, size-1].  For
     * example, this constructor call:
     *
     *     register<bit<32>>(512) my_reg;
     *
     * allocates storage for 512 values, each with type bit<32>.
     */
    register(bit<32> size); // FIXME -- arg should be `int` but that breaks typechecking
    /***
     * read() reads the state of the register array stored at the
     * specified index, and returns it as the value written to the
     * result parameter.
     *
     * @param index The index of the register array element to be
     *              read, normally a value in the range [0, size-1].
     * @param result Only types T that are bit<W> are currently
     *              supported.  When index is in range, the value of
     *              result becomes the value read from the register
     *              array element.  When index >= size, the final
     *              value of result is not specified, and should be
     *              ignored by the caller.
     */
    @noSideEffects



    void read(out T result, in bit<32> index);

    /***
     * write() writes the state of the register array at the specified
     * index, with the value provided by the value parameter.
     *
     * If you wish to perform a read() followed later by a write() to
     * the same register array element, and you wish the
     * read-modify-write sequence to be atomic relative to other
     * processed packets, then there may be parallel implementations
     * of the v1model architecture for which you must execute them in
     * a P4_16 block annotated with an @atomic annotation.  See the
     * P4_16 language specification description of the @atomic
     * annotation for more details.
     *
     * @param index The index of the register array element to be
     *              written, normally a value in the range [0,
     *              size-1].  If index >= size, no register state will
     *              be updated.
     * @param value Only types T that are bit<W> are currently
     *              supported.  When index is in range, this
     *              parameter's value is written into the register
     *              array element specified by index.
     */



    void write(in bit<32> index, in T value);

}

// used as table implementation attribute
extern action_profile {
    action_profile(bit<32> size);
}

/***
 * Generate a random number in the range lo..hi, inclusive, and write
 * it to the result parameter.  The value written to result is not
 * specified if lo > hi.
 *
 * @param T          Must be a type bit<W>
 */
extern void random<T>(out T result, in T lo, in T hi);

/***
 * Calling digest causes a message containing the values specified in
 * the data parameter to be sent to the control plane software.  It is
 * similar to sending a clone of the packet to the control plane
 * software, except that it can be more efficient because the messages
 * are typically smaller than packets, and many such small digest
 * messages are typically coalesced together into a larger "batch"
 * which the control plane software processes all at once.
 *
 * The value of the fields that are sent in the message to the control
 * plane is the value they have at the time the digest call occurs,
 * even if those field values are changed by later ingress control
 * code.  See Note 3.
 *
 * Calling digest is only supported in the ingress control.  There is
 * no way to undo its effects once it has been called.
 *
 * If the type T is a named struct, the name is used to generate the
 * control plane API.
 *
 * The BMv2 implementation of the v1model architecture ignores the
 * value of the receiver parameter.
 */
extern void digest<T>(in bit<32> receiver, in T data);

enum HashAlgorithm {
    crc32,
    crc32_custom,
    crc16,
    crc16_custom,
    random,
    identity,
    csum16,
    xor16
}

@deprecated("Please use mark_to_drop(standard_metadata) instead.")
extern void mark_to_drop();

/***
 * mark_to_drop(standard_metadata) is a primitive action that modifies
 * standard_metadata.egress_spec to an implementation-specific special
 * value that in some cases causes the packet to be dropped at the end
 * of ingress or egress processing.  It also assigns 0 to
 * standard_metadata.mcast_grp.  Either of those metadata fields may
 * be changed by executing later P4 code, after calling
 * mark_to_drop(), and this can change the resulting behavior of the
 * packet to do something other than drop.
 *
 * See
 * https://github.com/p4lang/behavioral-model/blob/master/docs/simple_switch.md
 * -- in particular the section "Pseudocode for what happens at the
 * end of ingress and egress processing" -- for the relative priority
 * of the different possible things that can happen to a packet when
 * ingress and egress processing are complete.
 */
@pure
extern void mark_to_drop(inout standard_metadata_t standard_metadata);

/***
 * Calculate a hash function of the value specified by the data
 * parameter.  The value written to the out parameter named result
 * will always be in the range [base, base+max-1] inclusive, if max >=
 * 1.  If max=0, the value written to result will always be base.
 *
 * Note that the types of all of the parameters may be the same as, or
 * different from, each other, and thus their bit widths are allowed
 * to be different.
 *
 * @param O          Must be a type bit<W>
 * @param D          Must be a tuple type where all the fields are bit-fields (type bit<W> or int<W>) or varbits.
 * @param T          Must be a type bit<W>
 * @param M          Must be a type bit<W>
 */
@pure
extern void hash<O, T, D, M>(out O result, in HashAlgorithm algo, in T base, in D data, in M max);

extern action_selector {
    action_selector(HashAlgorithm algorithm, bit<32> size, bit<32> outputWidth);
}

enum CloneType {
    I2E,
    E2E
}

@deprecated("Please use verify_checksum/update_checksum instead.")
extern Checksum16 {
    Checksum16();
    bit<16> get<D>(in D data);
}

/***
 * Verifies the checksum of the supplied data.  If this method detects
 * that a checksum of the data is not correct, then the value of the
 * standard_metadata checksum_error field will be equal to 1 when the
 * packet begins ingress processing.
 *
 * Calling verify_checksum is only supported in the VerifyChecksum
 * control.
 *
 * @param T          Must be a tuple type where all the tuple elements
 *                   are of type bit<W>, int<W>, or varbit<W>.  The
 *                   total length of the fields must be a multiple of
 *                   the output size.
 * @param O          Checksum type; must be bit<X> type.
 * @param condition  If 'false' the verification always succeeds.
 * @param data       Data whose checksum is verified.
 * @param checksum   Expected checksum of the data; note that it must
 *                   be a left-value.
 * @param algo       Algorithm to use for checksum (not all algorithms
 *                   may be supported).  Must be a compile-time
 *                   constant.
 */
extern void verify_checksum<T, O>(in bool condition, in T data, in O checksum, HashAlgorithm algo);

/***
 * Computes the checksum of the supplied data and writes it to the
 * checksum parameter.
 *
 * Calling update_checksum is only supported in the ComputeChecksum
 * control.
 *
 * @param T          Must be a tuple type where all the tuple elements
 *                   are of type bit<W>, int<W>, or varbit<W>.  The
 *                   total length of the fields must be a multiple of
 *                   the output size.
 * @param O          Output type; must be bit<X> type.
 * @param condition  If 'false' the checksum parameter is not changed
 * @param data       Data whose checksum is computed.
 * @param checksum   Checksum of the data.
 * @param algo       Algorithm to use for checksum (not all algorithms
 *                   may be supported).  Must be a compile-time
 *                   constant.
 */
@pure
extern void update_checksum<T, O>(in bool condition, in T data, inout O checksum, HashAlgorithm algo);

/***
 * verify_checksum_with_payload is identical in all ways to
 * verify_checksum, except that it includes the payload of the packet
 * in the checksum calculation.  The payload is defined as "all bytes
 * of the packet which were not parsed by the parser".
 *
 * Calling verify_checksum_with_payload is only supported in the
 * VerifyChecksum control.
 */
extern void verify_checksum_with_payload<T, O>(in bool condition, in T data, in O checksum, HashAlgorithm algo);

/**
 * update_checksum_with_payload is identical in all ways to
 * update_checksum, except that it includes the payload of the packet
 * in the checksum calculation.  The payload is defined as "all bytes
 * of the packet which were not parsed by the parser".
 *
 * Calling update_checksum_with_payload is only supported in the
 * ComputeChecksum control.
 */
@noSideEffects
extern void update_checksum_with_payload<T, O>(in bool condition, in T data, inout O checksum, HashAlgorithm algo);

/***
 * Calling resubmit during execution of the ingress control will,
 * under certain documented conditions, cause the packet to be
 * resubmitted, i.e. it will begin processing again with the parser,
 * with the contents of the packet exactly as they were when it last
 * began parsing.  The only difference is in the value of the
 * standard_metadata instance_type field, and any user-defined
 * metadata fields that the resubmit operation causes to be
 * preserved.
 *
 * The value of the user-defined metadata fields that are preserved in
 * resubmitted packets is the value they have at the end of ingress
 * processing, not their values at the time the resubmit call is made.
 * See Note 2 for issues with this.
 *
 * Calling resubmit is only supported in the ingress control.  There
 * is no way to undo its effects once it has been called.  If resubmit
 * is called multiple times during a single execution of the ingress
 * control, only one packet is resubmitted, and only the data from the
 * last such call is preserved.  See the v1model architecture
 * documentation (Note 1) for more details.
 */
extern void resubmit<T>(in T data);

/***
 * Calling recirculate during execution of the egress control will,
 * under certain documented conditions, cause the packet to be
 * recirculated, i.e. it will begin processing again with the parser,
 * with the contents of the packet as they are created by the
 * deparser.  Recirculated packets can be distinguished from new
 * packets in ingress processing by the value of the standard_metadata
 * instance_type field.  The caller may request that some user-defined
 * metadata fields be preserved with the recirculated packet.
 *
 * The value of the user-defined metadata fields that are preserved in
 * recirculated packets is the value they have at the end of egress
 * processing, not their values at the time the recirculate call is
 * made.  See Note 2 for issues with this.
 *
 * Calling recirculate is only supported in the egress control.  There
 * is no way to undo its effects once it has been called.  If
 * recirculate is called multiple times during a single execution of
 * the egress control, only one packet is recirculated, and only the
 * data from the last such call is preserved.  See the v1model
 * architecture documentation (Note 1) for more details.
 */
extern void recirculate<T>(in T data);

/***
 * clone is in most ways identical to the clone3 operation, with the
 * only difference being that it never preserves any user-defined
 * metadata fields with the cloned packet.  It is equivalent to
 * calling clone3 with the same type and session parameter values,
 * with empty data.
 */
extern void clone(in CloneType type, in bit<32> session);

/***
 * Calling clone3 during execution of the ingress or egress control
 * will cause the packet to be cloned, sometimes also called
 * mirroring, i.e. zero or more copies of the packet are made, and
 * each will later begin egress processing as an independent packet
 * from the original packet.  The original packet continues with its
 * normal next steps independent of the clone(s).
 *
 * The session parameter is an integer identifying a clone session id
 * (sometimes called a mirror session id).  The control plane software
 * must configure each session you wish to use, or else no clones will
 * be made using that session.  Typically this will involve the
 * control plane software specifying one output port to which the
 * cloned packet should be sent, or a list of (port, egress_rid) pairs
 * to which a separate clone should be created for each, similar to
 * multicast packets.
 *
 * Cloned packets can be distinguished from others by the value of the
 * standard_metadata instance_type field.
 *
 * The caller may request that some user-defined metadata field values
 * from the original packet should be preserved with the cloned
 * packet(s).  The value of the user-defined metadata fields that are
 * preserved with cloned packets is the value they have at the end of
 * ingress or egress processing, not their values at the time the
 * clone3 call is made.  See Note 2 for issues with this.
 *
 * If clone3 is called during ingress processing, the first parameter
 * must be CloneType.I2E.  If clone3 is called during egress
 * processing, the first parameter must be CloneType.E2E.
 *
 * There is no way to undo its effects once it has been called.  If
 * there are multiple calls to clone3 and/or clone during a single
 * execution of the same ingress (or egress) control, only the last
 * clone session and data are used.  See the v1model architecture
 * documentation (Note 1) for more details.
 */
extern void clone3<T>(in CloneType type, in bit<32> session, in T data);

extern void truncate(in bit<32> length);

/***
 * Calling assert when the argument is true has no effect, except any
 * effect that might occur due to evaluation of the argument (but see
 * below).  If the argument is false, the precise behavior is
 * target-specific, but the intent is to record or log which assert
 * statement failed, and optionally other information about the
 * failure.
 *
 * For example, on the simple_switch target, executing an assert
 * statement with a false argument causes a log message with the file
 * name and line number of the assert statement to be printed, and
 * then the simple_switch process exits.
 *
 * If you provide the --ndebug command line option to p4c when
 * compiling, the compiled program behaves as if all assert statements
 * were not present in the source code.
 *
 * We strongly recommend that you avoid using expressions as an
 * argument to an assert call that can have side effects, e.g. an
 * extern method or function call that has side effects.  p4c will
 * allow you to do this with no warning given.  We recommend this
 * because, if you follow this advice, your program will behave the
 * same way when assert statements are removed.
 */
extern void assert(in bool check);

/***
 * For the purposes of compiling and executing P4 programs on a target
 * device, assert and assume are identical, including the use of the
 * --ndebug p4c option to elide them.  See documentation for assert.
 *
 * The reason that assume exists as a separate function from assert is
 * because they are expected to be used differently by formal
 * verification tools.  For some formal tools, the goal is to try to
 * find example packets and sets of installed table entries that cause
 * an assert statement condition to be false.
 *
 * Suppose you run such a tool on your program, and the example packet
 * given is an MPLS packet, i.e. hdr.ethernet.etherType == 0x8847.
 * You look at the example, and indeed it does cause an assert
 * condition to be false.  However, your plan is to deploy your P4
 * program in a network in places where no MPLS packets can occur.
 * You could add extra conditions to your P4 program to handle the
 * processing of such a packet cleanly, without assertions failing,
 * but you would prefer to tell the tool "such example packets are not
 * applicable in my scenario -- never show them to me".  By adding a
 * statement:
 *
 *     assume(hdr.ethernet.etherType != 0x8847);
 *
 * at an appropriate place in your program, the formal tool should
 * never show you such examples -- only ones that make all such assume
 * conditions true.
 *
 * The reason that assume statements behave the same as assert
 * statements when compiled to a target device is that if the
 * condition ever evaluates to false when operating in a network, it
 * is likely that your assumption was wrong, and should be reexamined.
 */
extern void assume(in bool check);

/*
 * Log user defined messages
 * Example: log_msg("User defined message");
 * or log_msg("Value1 = {}, Value2 = {}",{value1, value2});
 */
extern void log_msg(string msg);
extern void log_msg<T>(string msg, in T data);

// The name 'standard_metadata' is reserved

/*
 * Architecture.
 *
 * M must be a struct.
 *
 * H must be a struct where every one if its members is of type
 * header, header stack, or header_union.
 */

parser Parser<H, M>(packet_in b,
                    out H parsedHdr,
                    inout M meta,
                    inout standard_metadata_t standard_metadata);

/*
 * The only legal statements in the body of the VerifyChecksum control
 * are: block statements, calls to the verify_checksum and
 * verify_checksum_with_payload methods, and return statements.
 */
control VerifyChecksum<H, M>(inout H hdr,
                             inout M meta);
@pipeline
control Ingress<H, M>(inout H hdr,
                      inout M meta,
                      inout standard_metadata_t standard_metadata);
@pipeline
control Egress<H, M>(inout H hdr,
                     inout M meta,
                     inout standard_metadata_t standard_metadata);

/*
 * The only legal statements in the body of the ComputeChecksum
 * control are: block statements, calls to the update_checksum and
 * update_checksum_with_payload methods, and return statements.
 */
control ComputeChecksum<H, M>(inout H hdr,
                              inout M meta);

/*
 * The only legal statements in the body of the Deparser control are:
 * calls to the packet_out.emit() method.
 */
@deparser
control Deparser<H>(packet_out b, in H hdr);

package V1Switch<H, M>(Parser<H, M> p,
                       VerifyChecksum<H, M> vr,
                       Ingress<H, M> ig,
                       Egress<H, M> eg,
                       ComputeChecksum<H, M> ck,
                       Deparser<H> dep
                       );
# 25 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/headers.p4" 1
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Damian Parniewicz, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
# 33 "/home/lchampagne/Documents/Test/int_v1.0/include/headers.p4"
// CPU_PORT specifies the P4 port number associated to controller packet-in and
// packet-out. All packets forwarded via this port will be delivered to the
// controller as P4Runtime PacketIn messages. Similarly, PacketOut messages from
// the controller will be seen by the P4 pipeline as coming from the CPU_PORT.


// CPU_CLONE_SESSION_ID specifies the mirroring session for packets to be cloned
// to the CPU port. Packets associated with this session ID will be cloned to
// the CPU_PORT as well as being transmitted via their egress port (set by the
// bridging/routing/acl table). For cloning to work, the P4Runtime controller
// needs first to insert a CloneSessionEntry that maps this session ID to the
// CPU_PORT.




typedef bit<9> port_num_t;
typedef bit<48> mac_addr_t;
typedef bit<16> mcast_group_id_t;
typedef bit<32> ipv4_addr_t;
typedef bit<128> ipv6_addr_t;
typedef bit<16> l4_port_t;

const bit<16> ETHERTYPE_IPV4 = 0x0800;
const bit<16> ETHERTYPE_IPV6 = 0x86dd;

const bit<8> IP_PROTO_ICMP = 1;
const bit<8> IP_PROTO_TCP = 6;
const bit<8> IP_PROTO_UDP = 17;
const bit<8> IP_PROTO_SRV6 = 43;
const bit<8> IP_PROTO_ICMPV6 = 58;

const mac_addr_t IPV6_MCAST_01 = 0x33_33_00_00_00_01;

const bit<8> ICMP6_TYPE_NS = 135;
const bit<8> ICMP6_TYPE_NA = 136;

const bit<8> NDP_OPT_TARGET_LL_ADDR = 2;

const bit<32> NDP_FLAG_ROUTER = 0x80000000;
const bit<32> NDP_FLAG_SOLICITED = 0x40000000;
const bit<32> NDP_FLAG_OVERRIDE = 0x20000000;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4> version;
    bit<4> ihl;
    bit<6> dscp;
    bit<2> ecn;
    bit<16> totalLen;
    bit<16> id;
    bit<3> flags;
    bit<13> fragOffset;
    bit<8> ttl;
    bit<8> protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header ipv6_t {
    bit<4> version;
    bit<6> traffic_class;
    bit<2> ecn;
    bit<20> flow_label;
    bit<16> payload_len;
    bit<8> next_hdr;
    bit<8> hop_limit;
    bit<128> src_addr;
    bit<128> dst_addr;
}

header srv6h_t {
    bit<8> next_hdr;
    bit<8> hdr_ext_len;
    bit<8> routing_type;
    bit<8> segment_left;
    bit<8> last_entry;
    bit<8> flags;
    bit<16> tag;
}

header srv6_list_t {
    bit<128> segment_id;
}

header icmp_t {
    bit<8> type;
    bit<8> icmp_code;
    bit<16> checksum;
    bit<16> identifier;
    bit<16> sequence_number;
    bit<64> timestamp;
}

header icmpv6_t {
    bit<8> type;
    bit<8> code;
    bit<16> checksum;
}

header ndp_t {
    bit<32> flags;
    ipv6_addr_t target_ipv6_addr;
    // NDP option.
    bit<8> type;
    bit<8> length;
    bit<48> target_mac_addr;
}

header udp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<16> len;
    bit<16> csum;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNum;
    bit<32> ackNum;
    bit<4> dataOffset;
    bit<3> reserved;
    bit<9> flags;
    bit<16> winSize;
    bit<16> csum;
    bit<16> urgPoint;
}

const bit<6> DSCP_INT = 0x20; // indicates an INT header in the packet
const bit<16> INT_SHIM_HEADER_LEN_BYTES = 4;
const bit<8> INT_TYPE_HOP_BY_HOP = 1;

header intl4_shim_t {
    bit<8> int_type;
    bit<8> rsvd1;
    bit<8> len; // the length of all INT headers in 4-byte words
    bit<6> dscp; // copy DSCP here
    bit<2> rsvd3;
}

const bit<16> INT_HEADER_LEN_BYTES = 8;
const bit<4> INT_VERSION = 1;

header int_header_t {
    bit<4> ver;
    bit<2> rep;
    bit<1> c;
    bit<1> e;
    bit<1> m;
    bit<7> rsvd1;
    bit<3> rsvd2;
    bit<5> hop_metadata_len; // the length of the metadata added by a single INT node (4-byte words)
    bit<8> remaining_hop_cnt; // how many switches can still add INT metadata
    bit<16> instruction_mask;
    bit<16> rsvd3;
}

const bit<16> INT_ALL_HEADER_LEN_BYTES = INT_SHIM_HEADER_LEN_BYTES + INT_HEADER_LEN_BYTES;

header int_switch_id_t {
    bit<32> switch_id;
}

header int_port_ids_t {
    bit<16> ingress_port_id;
    bit<16> egress_port_id;
}

header int_hop_latency_t {
    bit<32> hop_latency;
}

header int_q_occupancy_t {
    bit<8> q_id;
    bit<24> q_occupancy;
}

header int_ingress_tstamp_t {
    bit<64> ingress_tstamp;
}

header int_egress_tstamp_t {
    bit<64> egress_tstamp;
}

header int_level2_port_ids_t {
    bit<16> ingress_port_id;
    bit<16> egress_port_id;
}

header int_egress_port_tx_util_t {
    bit<32> egress_port_tx_util;
}


const bit<4> INT_REPORT_HEADER_LEN_WORDS = 4;
const bit<4> INT_REPORT_VERSION = 1;

header int_report_fixed_header_t {
    bit<4> ver;
    bit<4> len;
    bit<3> nprot;
    bit<5> rep_md_bits_high; // Split rep_md_bits to align to word boundaries
    bit<1> rep_md_bits_low;
    bit<6> reserved;
    bit<1> d;
    bit<1> q;
    bit<1> f;
    bit<6> hw_id;
    bit<32> switch_id;
    bit<32> seq_num;
    bit<32> ingress_tstamp;
}

struct int_metadata_t {
    bit<1> source; // is INT source functionality enabled
    bit<1> sink; // is INT sink functionality enabled
    bit<32> switch_id; // INT switch id is configured by network controller
    bit<16> insert_byte_cnt; // counter of inserted INT bytes
    bit<8> int_hdr_word_len; // counter of inserted INT words
    bit<1> remove_int; // indicator that all INT headers and data must be removed at egress for the processed packet 
    bit<16> sink_reporting_port; // on which port INT reports must be send to INT collector
    bit<64> ingress_tstamp; // pass ingress timestamp from Ingress pipeline to Egress pipeline
    bit<16> ingress_port; // pass ingress port from Ingress pipeline to Egress pipeline 
}

struct layer34_metadata_t {
    bit<32> ip_src;
    bit<32> ip_dst;
    bit<8> ip_ver;
    bit<16> l4_src;
    bit<16> l4_dst;
    bit<8> l4_proto;
    bit<16> l3_mtu;
    bit<6> dscp;
}

struct ecmp_metadata_t {
    bit<14> ecmp_hash;
    bit<14> ecmp_group_id;
}

struct metadata {
    int_metadata_t int_metadata;
    intl4_shim_t int_shim;
    layer34_metadata_t layer34_metadata;
    ecmp_metadata_t ecmp_metadata;
    bit<16> tcpLen;
    bool is_multicast;
    ipv6_addr_t next_srv6_sid;
    bit<8> ip_proto;
    bit<8> icmp_type;

    bit<48> flowlet_last_stamp;
    bit<48> flowlet_time_diff;

    bit<13> flowlet_register_index;
    //bit<16> flowlet_id;
    bool flow_source;
    bit<8> update_path;
}

header int_data_t {
    // Enough room for previous 4 nodes worth of data
    varbit<1600> data;
}


// Packet-in header. Prepended to packets sent to the CPU_PORT and used by the
// P4Runtime server (Stratum) to populate the PacketIn message metadata fields.
// Here we use it to carry the original ingress port where the packet was
// received.
@controller_header("packet_in")
header cpu_in_header_t {
    port_num_t ingress_port;
    bit<7> _pad;
}

// Packet-out header. Prepended to packets received from the CPU_PORT. Fields of
// this header are populated by the P4Runtime server based on the P4Runtime
// PacketOut metadata fields. Here we use it to inform the P4 pipeline on which
// port this packet-out should be transmitted.
@controller_header("packet_out")
header cpu_out_header_t {
    port_num_t egress_port;
    bit<7> _pad;
}

header flowlet_t {
    bit<8> update_path;
}


struct headers {

    // CPU headers
    cpu_out_header_t cpu_out;
    cpu_in_header_t cpu_in;

    // INT report headers
    ethernet_t report_ethernet;
    ipv4_t report_ipv4;
    udp_t report_udp;
    int_report_fixed_header_t report_fixed_header;

    // normal headers
    ethernet_t ethernet;
    ipv4_t ipv4;
    ipv6_t ipv6;

    // SRV6 headers
    srv6h_t srv6h;
    srv6_list_t[4] srv6_list;

    // L4 headers
    tcp_t tcp;
    udp_t udp;
    icmp_t icmp;
    icmpv6_t icmpv6;
    ndp_t ndp;

    // INT headers
    intl4_shim_t int_shim;
    int_header_t int_header;

    // local INT node metadata
    int_egress_port_tx_util_t int_egress_port_tx_util;
    int_egress_tstamp_t int_egress_tstamp;
    int_hop_latency_t int_hop_latency;
    int_ingress_tstamp_t int_ingress_tstamp;
    int_port_ids_t int_port_ids;
    int_level2_port_ids_t int_level2_port_ids;
    int_q_occupancy_t int_q_occupancy;
    int_switch_id_t int_switch_id;

    // INT metadata of previous nodes
    int_data_t int_data;

    flowlet_t flowlet;
}
# 26 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/parser.p4" 1
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Damian Parniewicz, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

error
{
 INTShimLenTooShort,
 INTVersionNotSupported
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
       transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_IPV4: parse_ipv4;
            ETHERTYPE_IPV6: parse_ipv6;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        meta.layer34_metadata.ip_src = hdr.ipv4.srcAddr;
        meta.layer34_metadata.ip_dst = hdr.ipv4.dstAddr;
        meta.layer34_metadata.ip_ver = 8w4;
        meta.layer34_metadata.dscp = hdr.ipv4.dscp;

        transition select(hdr.ipv4.protocol) {
            IP_PROTO_TCP: parse_tcp;
            IP_PROTO_UDP: parse_udp;
            IP_PROTO_ICMP: parse_icmp;
            default: accept;
        }
    }

    state parse_ipv6 {
        packet.extract(hdr.ipv6);
        meta.ip_proto = hdr.ipv6.next_hdr;
        //meta.layer34_metadata.ip_src = hdr.ipv6.src_addr;
        //meta.layer34_metadata.ip_dst = hdr.ipv6.dst_addr;
        meta.layer34_metadata.ip_ver = 8w6;
        meta.layer34_metadata.dscp = hdr.ipv6.traffic_class;
        transition select(hdr.ipv6.next_hdr) {
            IP_PROTO_TCP: parse_tcp;
            IP_PROTO_UDP: parse_udp;
            IP_PROTO_ICMPV6: parse_icmpv6;
            IP_PROTO_SRV6: parse_srv6;
            default: accept;
        }
    }

    state parse_tcp {
        packet.extract(hdr.tcp);
        meta.layer34_metadata.l4_src = hdr.tcp.srcPort;
        meta.layer34_metadata.l4_dst = hdr.tcp.dstPort;
        meta.layer34_metadata.l4_proto = 8w0x6;
        transition select(meta.layer34_metadata.dscp) {
            DSCP_INT: parse_int;
            default: accept;
        }
    }

    state parse_udp {
        packet.extract(hdr.udp);
        meta.layer34_metadata.l4_src = hdr.udp.srcPort;
        meta.layer34_metadata.l4_dst = hdr.udp.dstPort;
        meta.layer34_metadata.l4_proto = 8w0x11;
        transition select(meta.layer34_metadata.dscp, hdr.udp.dstPort) {
            (6w0x20 &&& 6w0x3f, 16w0x0 &&& 16w0x0): parse_int;
            default: accept;
        }
    }

    state parse_icmp {
        packet.extract(hdr.icmp);
        meta.icmp_type = hdr.icmp.type;
        transition accept;
    }

        state parse_icmpv6 {
        packet.extract(hdr.icmpv6);
        meta.icmp_type = hdr.icmpv6.type;
        transition select(hdr.icmpv6.type) {
            ICMP6_TYPE_NS: parse_ndp;
            ICMP6_TYPE_NA: parse_ndp;
            default: accept;
        }
    }

    state parse_ndp {
        packet.extract(hdr.ndp);
        transition accept;
    }

    state parse_srv6 {
        packet.extract(hdr.srv6h);
        transition parse_srv6_list;
    }

    state parse_srv6_list {
        packet.extract(hdr.srv6_list.next);
        log_msg("Test:{} {}\n", {hdr.srv6h.segment_left, hdr.srv6_list.lastIndex});
        bool next_segment = (bit<32>)hdr.srv6h.segment_left - 1 == (bit<32>)hdr.srv6_list.lastIndex;
        transition select(next_segment) {
            true: mark_current_srv6;
            default: check_last_srv6;
        }
    }

    state mark_current_srv6 {
        meta.next_srv6_sid = hdr.srv6_list.last.segment_id;
        transition check_last_srv6;
    }

    state check_last_srv6 {
        // working with bit<8> and int<32> which cannot be cast directly; using
        // bit<32> as common intermediate type for comparision
        bool last_segment = (bit<32>)hdr.srv6h.last_entry == (bit<32>)hdr.srv6_list.lastIndex;
        transition select(last_segment) {
           true: parse_srv6_next_hdr;
           false: parse_srv6_list;
        }
    }

    state parse_srv6_next_hdr {
        transition select(hdr.srv6h.next_hdr) {
            IP_PROTO_TCP: parse_tcp;
            IP_PROTO_UDP: parse_udp;
            IP_PROTO_ICMPV6: parse_icmpv6;
            default: accept;
        }
    }

    state parse_int {
        packet.extract(hdr.int_shim);
        /*verify(hdr.int_shim.len >= 3, error.INTShimLenTooShort);*/
        packet.extract(hdr.int_header);
        // DAMU: warning (from TOFINO): Parser "verify" is currently unsupported
        /*verify(hdr.int_header.ver == INT_VERSION, error.INTVersionNotSupported);*/
        packet.extract(hdr.int_data, (bit<32>) (hdr.int_shim.len - 3)*32);
        transition accept;
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {

        // CPU header
        packet.emit(hdr.cpu_in);

        // report headers
        packet.emit(hdr.report_ethernet);
        packet.emit(hdr.report_ipv4);
        packet.emit(hdr.report_udp);
        packet.emit(hdr.report_fixed_header);

        // original headers
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.ipv6);

        //SRV6 headers
        packet.emit(hdr.srv6h);
        packet.emit(hdr.srv6_list);

        packet.emit(hdr.udp);
        packet.emit(hdr.tcp);
        packet.emit(hdr.icmp);
        packet.emit(hdr.icmpv6);
        packet.emit(hdr.ndp);

        packet.emit(hdr.flowlet);

        // INT headers
        packet.emit(hdr.int_shim);
        packet.emit(hdr.int_header);

        // local INT node metadata
        packet.emit(hdr.int_switch_id); //bit 1
        packet.emit(hdr.int_port_ids); //bit 2
        packet.emit(hdr.int_hop_latency); //bit 3
        packet.emit(hdr.int_q_occupancy); // bit 4
        packet.emit(hdr.int_ingress_tstamp); // bit 5
        packet.emit(hdr.int_egress_tstamp); // bit 6
        packet.emit(hdr.int_level2_port_ids); // bit 7
        packet.emit(hdr.int_egress_port_tx_util); // bit 8

        //previous nodes int data
        packet.emit(hdr.int_data);

    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum(
            hdr.ipv4.isValid(),
            {
                hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.dscp,
                hdr.ipv4.ecn,
                hdr.ipv4.totalLen,
                hdr.ipv4.id,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr
            },
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16
        );

        update_checksum(
            hdr.report_ipv4.isValid(),
            {
                hdr.report_ipv4.version,
                hdr.report_ipv4.ihl,
                hdr.report_ipv4.dscp,
                hdr.report_ipv4.ecn,
                hdr.report_ipv4.totalLen,
                hdr.report_ipv4.id,
                hdr.report_ipv4.flags,
                hdr.report_ipv4.fragOffset,
                hdr.report_ipv4.ttl,
                hdr.report_ipv4.protocol,
                hdr.report_ipv4.srcAddr,
                hdr.report_ipv4.dstAddr
            },
            hdr.report_ipv4.hdrChecksum,
            HashAlgorithm.csum16
        );

        update_checksum(hdr.ndp.isValid(),
            {
                hdr.ipv6.src_addr,
                hdr.ipv6.dst_addr,
                hdr.ipv6.payload_len,
                8w0,
                hdr.ipv6.next_hdr,
                hdr.icmpv6.type,
                hdr.icmpv6.code,
                hdr.ndp.flags,
                hdr.ndp.target_ipv6_addr,
                hdr.ndp.type,
                hdr.ndp.length,
                hdr.ndp.target_mac_addr
            },
            hdr.icmpv6.checksum,
            HashAlgorithm.csum16
        );

        update_checksum_with_payload(
            hdr.udp.isValid(),
            { hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr,
                8w0,
                hdr.ipv4.protocol,
                hdr.udp.len,
                hdr.udp.srcPort,
                hdr.udp.dstPort,
                hdr.udp.len
            },
            hdr.udp.csum,
            HashAlgorithm.csum16
        );

        update_checksum_with_payload(
            hdr.udp.isValid() && hdr.int_header.isValid() ,
            { hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr,
                8w0,
                hdr.ipv4.protocol,
                hdr.udp.len,
                hdr.udp.srcPort,
                hdr.udp.dstPort,
                hdr.udp.len,
                hdr.int_shim,
                hdr.int_header,
                hdr.int_switch_id,
                hdr.int_port_ids,
                hdr.int_q_occupancy,
                hdr.int_level2_port_ids,
                hdr.int_ingress_tstamp,
                hdr.int_egress_tstamp,
                hdr.int_egress_port_tx_util,
                hdr.int_hop_latency
            },
            hdr.udp.csum,
            HashAlgorithm.csum16
        );


        update_checksum_with_payload(
            hdr.tcp.isValid(),
            { hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr,
                8w0,
                hdr.ipv4.protocol,
                meta.tcpLen,
                hdr.tcp.srcPort,
                hdr.tcp.dstPort,
                hdr.tcp.seqNum,
                hdr.tcp.ackNum,
                hdr.tcp.dataOffset,
                hdr.tcp.reserved,
                hdr.tcp.flags,
                hdr.tcp.winSize,
                hdr.tcp.urgPoint
            },
            hdr.tcp.csum, HashAlgorithm.csum16);

        update_checksum_with_payload(
            hdr.tcp.isValid() && hdr.int_header.isValid(),
            { hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr,
                8w0,
                hdr.ipv4.protocol,
                meta.tcpLen,
                hdr.tcp.srcPort,
                hdr.tcp.dstPort,
                hdr.tcp.seqNum,
                hdr.tcp.ackNum,
                hdr.tcp.dataOffset,
                hdr.tcp.reserved,
                hdr.tcp.flags,
                hdr.tcp.winSize,
                16w0,
                hdr.tcp.urgPoint,
                hdr.int_shim,
                hdr.int_header,
                hdr.int_switch_id,
                hdr.int_port_ids,
                hdr.int_q_occupancy,
                hdr.int_level2_port_ids,
                hdr.int_ingress_tstamp,
                hdr.int_egress_tstamp,
                hdr.int_egress_port_tx_util,
                hdr.int_hop_latency
            },
            hdr.tcp.csum, HashAlgorithm.csum16);
    }
}
# 27 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/int_source.p4" 1
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Damian Parniewicz, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




control Int_source(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

    // Configure parameters of INT source node
    // max_hop - how many INT nodes can add their INT node metadata
    // hope_metadata_len - how INT metadata words are added by a single INT node
    // ins_cnt - how many INT headers must be added by a single INT node
    // ins_mask - instruction_mask defining which information (INT headers types) must added to the packet
    action configure_source(bit<8> max_hop, bit<5> hop_metadata_len, bit<5> ins_cnt, bit<16> ins_mask) {

        hdr.int_shim.setValid();
        hdr.int_shim.int_type = INT_TYPE_HOP_BY_HOP;
        hdr.int_shim.len = (bit<8>)INT_ALL_HEADER_LEN_BYTES>>2;

        hdr.int_header.setValid();
        hdr.int_header.ver = INT_VERSION;
        hdr.int_header.rep = 0;
        hdr.int_header.c = 0;
        hdr.int_header.e = 0;
        hdr.int_header.rsvd1 = 0;
        hdr.int_header.rsvd2 = 0;
        hdr.int_header.hop_metadata_len = hop_metadata_len;
        hdr.int_header.remaining_hop_cnt = max_hop; //will be decreased immediately by 1 within transit process
        hdr.int_header.instruction_mask = ins_mask;

        if(hdr.ipv4.isValid()){
            hdr.int_shim.dscp = hdr.ipv4.dscp;
            hdr.ipv4.dscp = DSCP_INT; // indicates that INT header in the packet
            hdr.ipv4.totalLen = hdr.ipv4.totalLen + INT_ALL_HEADER_LEN_BYTES; // adding size of INT headers
        } else {
            hdr.int_shim.dscp = hdr.ipv6.traffic_class;
            hdr.ipv6.traffic_class = DSCP_INT; // indicates that INT header in the packet
            hdr.ipv6.payload_len = hdr.ipv6.payload_len + INT_ALL_HEADER_LEN_BYTES; // adding size of INT headers
        }


        hdr.udp.len = hdr.udp.len + INT_ALL_HEADER_LEN_BYTES;
    }

    // INT source must be configured per each flow which must be monitored using INT
    // Flow is defined by src IP, dst IP, src TCP/UDP port, dst TCP/UDP port 
    // When INT source configured for a flow then a node adds INT shim header and first INT node metadata headers
    table tb_int_source {
        actions = {
            configure_source;
        }
        key = {
            hdr.ipv4.srcAddr : ternary;
            hdr.ipv4.dstAddr : ternary;
            meta.layer34_metadata.l4_src: ternary;
            meta.layer34_metadata.l4_dst: ternary;
        }
        size = 127;
    }


    table tb_intv6_source {
        actions = {
            configure_source;
        }
        key = {
            hdr.ipv6.src_addr : ternary;
            hdr.ipv6.dst_addr : ternary;
            meta.layer34_metadata.l4_src: ternary;
            meta.layer34_metadata.l4_dst: ternary;
        }
        size = 127;
    }


    action activate_source() {
        meta.int_metadata.source = 1;
    }

    // table used to active INT source for a ingress port of the switch
    table tb_activate_source {
        actions = {
            activate_source;
        }
        key = {
            standard_metadata.ingress_port: exact;
        }
        size = 255;
    }


    apply {


        // in case of frame clone for the INT sink reporting
        // ingress timestamp is not available on Egress pipeline
        meta.int_metadata.ingress_tstamp = (bit<64>) standard_metadata.ingress_global_timestamp;
        meta.int_metadata.ingress_port = (bit<16>)standard_metadata.ingress_port;
        //check if packet appeard on ingress port with active INT source
        tb_activate_source.apply();

        bit<8> res = 0;
        random<bit<8>>(res, 1, 1);

        if (meta.int_metadata.source == 1 && hdr.ipv4.isValid()) {
            if(res != 1){
                meta.int_metadata.source = 0;
                return;
            }
            //apply INT source logic on INT monitored flow
            tb_int_source.apply();
        }

        if (meta.int_metadata.source == 1 && hdr.ipv6.isValid()) {
            log_msg("random res: {}", {res});
            if(res != 1){
                meta.int_metadata.source = 0;
                return;
            }
            //apply INT source logic on INT monitored flow
            tb_intv6_source.apply();
        }
    }
}
# 28 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/int_transit.p4" 1
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Damian Parniewicz, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


control Int_transit(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

        // Configure parameters of INT transit node:
        // switch_id which is used within INT node metadata
        // l3_mtu is curently not used but should allow to detect condition if adding new INT metadata will exceed allowed MTU packet size

        action configure_transit(bit<32> switch_id, bit<16> l3_mtu) {
            meta.int_metadata.switch_id = switch_id;
            meta.int_metadata.insert_byte_cnt = 0;
            meta.int_metadata.int_hdr_word_len = 0;
            meta.layer34_metadata.l3_mtu = l3_mtu;
        }

        // Table used to configure a switch as a INT transit
        // If INT transit configured then all packets with INT header will be precessed by INT transit logic
        table tb_int_transit {
            actions = {
                configure_transit;
            }
        }

        action int_set_header_0() {
            hdr.int_switch_id.setValid();
            hdr.int_switch_id.switch_id = meta.int_metadata.switch_id;
        }
        action int_set_header_1() {
            hdr.int_port_ids.setValid();
            //hdr.int_port_ids.ingress_port_id = (bit<16>)standard_metadata.ingress_port;
            hdr.int_port_ids.ingress_port_id = meta.int_metadata.ingress_port;
            hdr.int_port_ids.egress_port_id = (bit<16>)standard_metadata.egress_port;
        }
        action int_set_header_2() {
            hdr.int_hop_latency.setValid();
            hdr.int_hop_latency.hop_latency = (bit<32>)(standard_metadata.egress_global_timestamp - standard_metadata.ingress_global_timestamp);
            if (standard_metadata.instance_type == 1) {
                hdr.int_hop_latency.hop_latency = hdr.int_hop_latency.hop_latency - (bit<32>) meta.int_metadata.ingress_tstamp;
            }
            log_msg("hop: {} {} {}", {hdr.int_hop_latency.hop_latency, standard_metadata.ingress_global_timestamp, meta.int_metadata.ingress_tstamp});
        }
        action int_set_header_3() {
            hdr.int_q_occupancy.setValid();
            hdr.int_q_occupancy.q_id = 0; // qid not defined in v1model
            hdr.int_q_occupancy.q_occupancy = (bit<24>)standard_metadata.enq_qdepth;
        }
        action int_set_header_4() {
            hdr.int_ingress_tstamp.setValid();
            bit<64> _timestamp = (bit<64>)meta.int_metadata.ingress_tstamp;
            hdr.int_ingress_tstamp.ingress_tstamp = hdr.int_ingress_tstamp.ingress_tstamp + 1000 * _timestamp;
        }
        action int_set_header_5() {
            hdr.int_egress_tstamp.setValid();
            bit<64> _timestamp = (bit<64>)standard_metadata.egress_global_timestamp;
            hdr.int_egress_tstamp.egress_tstamp = hdr.int_egress_tstamp.egress_tstamp + 1000 * _timestamp;
        }
        action int_set_header_6() {
            hdr.int_level2_port_ids.setValid();
            // no such metadata in v1model
            hdr.int_level2_port_ids.ingress_port_id = 0;
            hdr.int_level2_port_ids.egress_port_id = 0;
        }
        action int_set_header_7() {
            hdr.int_egress_port_tx_util.setValid();
            // no such metadata in v1model
            hdr.int_egress_port_tx_util.egress_port_tx_util = 0;
        }

        action add_1() {
            meta.int_metadata.int_hdr_word_len = meta.int_metadata.int_hdr_word_len + 1;
            meta.int_metadata.insert_byte_cnt = meta.int_metadata.insert_byte_cnt + 4;
        }

        action add_2() {
            meta.int_metadata.int_hdr_word_len = meta.int_metadata.int_hdr_word_len + 2;
            meta.int_metadata.insert_byte_cnt = meta.int_metadata.insert_byte_cnt + 8;
        }

        action add_3() {
            meta.int_metadata.int_hdr_word_len = meta.int_metadata.int_hdr_word_len + 3;
            meta.int_metadata.insert_byte_cnt = meta.int_metadata.insert_byte_cnt + 12;
        }

        action add_4() {
            meta.int_metadata.int_hdr_word_len = meta.int_metadata.int_hdr_word_len + 4;
            meta.int_metadata.insert_byte_cnt = meta.int_metadata.insert_byte_cnt + 16;
        }


        action add_5() {
            meta.int_metadata.int_hdr_word_len = meta.int_metadata.int_hdr_word_len + 5;
            meta.int_metadata.insert_byte_cnt = meta.int_metadata.insert_byte_cnt + 20;
        }

        action add_6() {
            meta.int_metadata.int_hdr_word_len = meta.int_metadata.int_hdr_word_len + 6;
            meta.int_metadata.insert_byte_cnt = meta.int_metadata.insert_byte_cnt + 24;
        }

        // hdr.int_switch_id     0
        // hdr.int_port_ids       1
        // hdr.int_hop_latency    2
        // hdr.int_q_occupancy    3
        // hdr.int_ingress_tstamp  4
        // hdr.int_egress_tstamp   5
        // hdr.int_level2_port_ids   6
        // hdr.int_egress_port_tx_util   7

        action int_set_header_0003_i0() {
            ;
        }
        action int_set_header_0003_i1() {
            int_set_header_3();
            add_1();
        }
        action int_set_header_0003_i2() {
            int_set_header_2();
            add_1();
        }
        action int_set_header_0003_i3() {
            int_set_header_5();
            int_set_header_2();
            add_3();
        }
        action int_set_header_0003_i4() {
            int_set_header_1();
            add_1();
        }
        action int_set_header_0003_i5() {
            int_set_header_3();
            int_set_header_1();
            add_2();
        }
        action int_set_header_0003_i6() {
            int_set_header_2();
            int_set_header_1();
            add_2();
        }
        action int_set_header_0003_i7() {
            int_set_header_3();
            int_set_header_2();
            int_set_header_1();
            add_3();
        }
        action int_set_header_0003_i8() {
            int_set_header_0();
            add_1();
        }
        action int_set_header_0003_i9() {
            int_set_header_3();
            int_set_header_0();
            add_2();
        }
        action int_set_header_0003_i10() {
            int_set_header_2();
            int_set_header_0();
            add_2();
        }
        action int_set_header_0003_i11() {
            int_set_header_3();
            int_set_header_2();
            int_set_header_0();
            add_3();
        }
        action int_set_header_0003_i12() {
            int_set_header_1();
            int_set_header_0();
            add_2();
        }
        action int_set_header_0003_i13() {
            int_set_header_3();
            int_set_header_1();
            int_set_header_0();
            add_3();
        }
        action int_set_header_0003_i14() {
            int_set_header_2();
            int_set_header_1();
            int_set_header_0();
            add_3();
        }
        action int_set_header_0003_i15() {
            int_set_header_3();
            int_set_header_2();
            int_set_header_1();
            int_set_header_0();
            add_4();
        }
        action int_set_header_0407_i0() {
            ;
        }

        action int_set_header_0407_i1() {
            int_set_header_7();
            add_1();
        }
        action int_set_header_0407_i2() {
            int_set_header_6();
            add_1();
        }
        action int_set_header_0407_i3() {
            int_set_header_7();
            int_set_header_6();
            add_2();

        }
        action int_set_header_0407_i4() {
            int_set_header_5();
            add_2();
        }
        action int_set_header_0407_i5() {
            int_set_header_7();
            int_set_header_5();
            add_3();
        }
        action int_set_header_0407_i6() {
            int_set_header_6();
            int_set_header_5();
            add_3();
        }
        action int_set_header_0407_i7() {
            int_set_header_7();
            int_set_header_6();
            int_set_header_5();
            add_4();
        }
        action int_set_header_0407_i8() {
            int_set_header_4();
            add_2();
        }
        action int_set_header_0407_i9() {
            int_set_header_7();
            int_set_header_4();
            add_3();
        }
        action int_set_header_0407_i10() {
            int_set_header_6();
            int_set_header_4();
            add_3();
        }
        action int_set_header_0407_i11() {
            int_set_header_7();
            int_set_header_6();
            int_set_header_4();
            add_4();
        }
        action int_set_header_0407_i12() {
            int_set_header_5();
            int_set_header_4();
            add_4();
        }
        action int_set_header_0407_i13() {
            int_set_header_7();
            int_set_header_5();
            int_set_header_4();
            add_5();
        }
        action int_set_header_0407_i14() {
            int_set_header_6();
            int_set_header_5();
            int_set_header_4();
            add_5();
        }
        action int_set_header_0407_i15() {
            int_set_header_7();
            int_set_header_6();
            int_set_header_5();
            int_set_header_4();
            add_6();
        }


        table tb_int_inst_0003 {
            actions = {
                int_set_header_0003_i0;
                int_set_header_0003_i1;
                int_set_header_0003_i2;
                int_set_header_0003_i3;
                int_set_header_0003_i4;
                int_set_header_0003_i5;
                int_set_header_0003_i6;
                int_set_header_0003_i7;
                int_set_header_0003_i8;
                int_set_header_0003_i9;
                int_set_header_0003_i10;
                int_set_header_0003_i11;
                int_set_header_0003_i12;
                int_set_header_0003_i13;
                int_set_header_0003_i14;
                int_set_header_0003_i15;
            }
            key = {
                hdr.int_header.instruction_mask: ternary;
            }
            const entries = {
                0x0000 &&& 0xF000 : int_set_header_0003_i0();
                0x1000 &&& 0xF000 : int_set_header_0003_i1();
                0x2000 &&& 0xF000 : int_set_header_0003_i2();
                0x3000 &&& 0xF000 : int_set_header_0003_i3();
                0x4000 &&& 0xF000 : int_set_header_0003_i4();
                0x5000 &&& 0xF000 : int_set_header_0003_i5();
                0x6000 &&& 0xF000 : int_set_header_0003_i6();
                0x7000 &&& 0xF000 : int_set_header_0003_i7();
                0x8000 &&& 0xF000 : int_set_header_0003_i8();
                0x9000 &&& 0xF000 : int_set_header_0003_i9();
                0xA000 &&& 0xF000 : int_set_header_0003_i10();
                0xB000 &&& 0xF000 : int_set_header_0003_i11();
                0xC000 &&& 0xF000 : int_set_header_0003_i12();
                0xD000 &&& 0xF000 : int_set_header_0003_i13();
                0xE000 &&& 0xF000 : int_set_header_0003_i14();
                0xF000 &&& 0xF000 : int_set_header_0003_i15();
            }
        }

        table tb_int_inst_0407 {
            actions = {
                int_set_header_0407_i0;
                int_set_header_0407_i1;
                int_set_header_0407_i2;
                int_set_header_0407_i3;
                int_set_header_0407_i4;
                int_set_header_0407_i5;
                int_set_header_0407_i6;
                int_set_header_0407_i7;
                int_set_header_0407_i8;
                int_set_header_0407_i9;
                int_set_header_0407_i10;
                int_set_header_0407_i11;
                int_set_header_0407_i12;
                int_set_header_0407_i13;
                int_set_header_0407_i14;
                int_set_header_0407_i15;
            }
            key = {
                hdr.int_header.instruction_mask: ternary;
            }
            const entries = {
                0x0000 &&& 0x0F00 : int_set_header_0407_i0();
                0x0100 &&& 0x0F00 : int_set_header_0407_i1();
                0x0200 &&& 0x0F00 : int_set_header_0407_i2();
                0x0300 &&& 0x0F00 : int_set_header_0407_i3();
                0x0400 &&& 0x0F00 : int_set_header_0407_i4();
                0x0500 &&& 0x0F00 : int_set_header_0407_i5();
                0x0600 &&& 0x0F00 : int_set_header_0407_i6();
                0x0700 &&& 0x0F00 : int_set_header_0407_i7();
                0x0800 &&& 0x0F00 : int_set_header_0407_i8();
                0x0900 &&& 0x0F00 : int_set_header_0407_i9();
                0x0A00 &&& 0x0F00 : int_set_header_0407_i10();
                0x0B00 &&& 0x0F00 : int_set_header_0407_i11();
                0x0C00 &&& 0x0F00 : int_set_header_0407_i12();
                0x0D00 &&& 0x0F00 : int_set_header_0407_i13();
                0x0E00 &&& 0x0F00 : int_set_header_0407_i14();
                0x0F00 &&& 0x0F00 : int_set_header_0407_i15();
            }
        }


        action int_hop_cnt_increment() {
            hdr.int_header.remaining_hop_cnt = hdr.int_header.remaining_hop_cnt - 1;
        }
        action int_hop_exceeded() {
            hdr.int_header.e = 1w1;
        }

        action int_update_ip_ac() {
            if(hdr.ipv4.isValid())
                hdr.ipv4.totalLen = hdr.ipv4.totalLen + (bit<16>)meta.int_metadata.insert_byte_cnt;
            else
                hdr.ipv6.payload_len = hdr.ipv6.payload_len + (bit<16>)meta.int_metadata.insert_byte_cnt;
        }
        action int_update_shim_ac() {
            hdr.int_shim.len = hdr.int_shim.len + (bit<8>)meta.int_metadata.int_hdr_word_len;
        }
        action int_update_udp_ac() {
            hdr.udp.len = hdr.udp.len + (bit<16>)meta.int_metadata.insert_byte_cnt;
        }

        apply {

            // INT transit must process only INT packets
            if (!hdr.int_header.isValid())
                return;

            //TODO: check if hop-by-hop INT or destination INT

            // check if INT transit can add a new INT node metadata
            if (hdr.int_header.remaining_hop_cnt == 0 || hdr.int_header.e == 1) {
                int_hop_exceeded();
                return;
            }

            int_hop_cnt_increment();

            // add INT node metadata headers based on INT instruction_mask
            tb_int_transit.apply();
            tb_int_inst_0003.apply();
            tb_int_inst_0407.apply();

            log_msg("Q depth transit: {}", {standard_metadata.enq_qdepth});

            //update length fields in IP, UDP and INT
            int_update_ip_ac();

            if (hdr.udp.isValid())
                int_update_udp_ac();

            if (hdr.int_shim.isValid())
                int_update_shim_ac();
        }
    }
# 29 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/int_sink.p4" 1
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Damian Parniewicz, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/int_report.p4" 1
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Bartosz Krakowiak, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code adapted from:
// - https://github.com/baru64/int-p4/blob/master/int.p4app/p4src/int_report.p4

// register to store seq_num
register<bit<32>> (1) report_seq_num_register;

control Int_report(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

        bit<32> seq_num_value = 0;

        // INT Report structure
        // [Eth][IP][UDP][INT REPORT HDR][ETH][IP][UDP/TCP][INT SHIM][INT DATA]

        action send_report(bit<48> dp_mac, bit<32> dp_ip, bit<48> collector_mac, bit<32> collector_ip, bit<16> collector_port) {

            log_msg("Sending report\n");
            // Ethernet **********************************************************
            hdr.report_ethernet.setValid();
            hdr.report_ethernet.dstAddr = collector_mac;
            hdr.report_ethernet.srcAddr = dp_mac;
            hdr.report_ethernet.etherType = 0x0800;

            // IPv4 **************************************************************
            hdr.report_ipv4.setValid();
            hdr.report_ipv4.version = 4;
            hdr.report_ipv4.ihl = 5;
            hdr.report_ipv4.dscp = 0;
            hdr.report_ipv4.ecn = 0;

            if(hdr.ipv4.isValid()){
                // 2x ipv4 header (20*2) + udp header (8) + eth header (14) + report header (16) + int data len
                hdr.report_ipv4.totalLen = (bit<16>)(20 + 20 + 8 + 14)
                    + ((bit<16>)(INT_REPORT_HEADER_LEN_WORDS)<<2)
                    + (((bit<16>)hdr.int_shim.len) << 2);
            } else {
                // ipv4 header (20) + ipv6 header (40) + udp header (8) + eth header (14) + report header (16) + int data len
                hdr.report_ipv4.totalLen = (bit<16>)(20 + 40 + 8 + 14)
                    + ((bit<16>)(INT_REPORT_HEADER_LEN_WORDS)<<2)
                    + (((bit<16>)hdr.int_shim.len) << 2);
                if (hdr.ipv6.next_hdr == IP_PROTO_SRV6) {
                    hdr.report_ipv4.totalLen = hdr.report_ipv4.totalLen + 8 + (((bit<16>)hdr.srv6h.last_entry+1)*16);
                }
            }

            // add size of original tcp/udp header
            if (hdr.tcp.isValid()) {
                hdr.report_ipv4.totalLen = hdr.report_ipv4.totalLen
                    + (((bit<16>)hdr.tcp.dataOffset) << 2);

            } else {
                hdr.report_ipv4.totalLen = hdr.report_ipv4.totalLen + 8;
            }

            hdr.report_ipv4.id = 0;
            hdr.report_ipv4.flags = 0;
            hdr.report_ipv4.fragOffset = 0;
            hdr.report_ipv4.ttl = 64;
            hdr.report_ipv4.protocol = 17; // UDP
            hdr.report_ipv4.srcAddr = dp_ip;
            hdr.report_ipv4.dstAddr = collector_ip;

            // UDP ***************************************************************
            hdr.report_udp.setValid();
            hdr.report_udp.srcPort = 0;
            hdr.report_udp.dstPort = collector_port;
            hdr.report_udp.len = hdr.report_ipv4.totalLen - 20;

            // INT report fixed header ************************************************/
            // INT report version 1.0
            hdr.report_fixed_header.setValid();
            hdr.report_fixed_header.ver = INT_REPORT_VERSION;
            hdr.report_fixed_header.len = INT_REPORT_HEADER_LEN_WORDS;

            hdr.report_fixed_header.nprot = 0; // 0 for Ethernet
            hdr.report_fixed_header.rep_md_bits_high = 0;
            hdr.report_fixed_header.rep_md_bits_low = 0;
            hdr.report_fixed_header.reserved = 0;
            hdr.report_fixed_header.d = 0;
            hdr.report_fixed_header.q = 0;
            // f - indicates that report is for tracked flow, INT data is present
            hdr.report_fixed_header.f = 1;
            // hw_id - specific to the switch, e.g. id of linecard
            hdr.report_fixed_header.hw_id = 0;
            hdr.report_fixed_header.switch_id = meta.int_metadata.switch_id;
            report_seq_num_register.read(seq_num_value, 0);
            hdr.report_fixed_header.seq_num = seq_num_value;
            report_seq_num_register.write(0, seq_num_value + 1);

            hdr.report_fixed_header.ingress_tstamp = (bit<32>)standard_metadata.ingress_global_timestamp;

            hdr.flowlet.setValid();
            hdr.flowlet.update_path = meta.update_path;

            // Original packet headers, INT shim and INT data come after report header.
            // drop all data besides int report and report eth header
            truncate((bit<32>)hdr.report_ipv4.totalLen + 14 + 1);
        }

        table tb_int_reporting {
            actions = {
                send_report;
            }
            //size=512;
        }

        apply {
            tb_int_reporting.apply();
        }
    }
# 22 "/home/lchampagne/Documents/Test/int_v1.0/include/int_sink.p4" 2

const bit<32> INT_REPORT_MIRROR_SESSION_ID = 1; // mirror session specyfing egress_port for cloned INT report packets, defined by switch CLI command   

control Int_sink_config(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action configure_sink(bit<16> sink_reporting_port) {
        meta.int_metadata.remove_int = 1; // indicate that INT headers must be removed in egress
        meta.int_metadata.sink_reporting_port = (bit<16>)sink_reporting_port;
        log_msg("packet ready to be cloned");
        clone3<metadata>(CloneType.I2E, INT_REPORT_MIRROR_SESSION_ID, meta);
    }

    //table used to activate INT sink for particular egress port of the switch
    table tb_int_sink {
        actions = {
            configure_sink;
        }
        key = {
            standard_metadata.egress_spec: exact;
        }
        size = 255;
    }

    apply {
       // INT sink must process only INT packets
        if (hdr.int_header.isValid())
            tb_int_sink.apply();
    }
}

control Int_sink(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

    action remove_sink_header() {
        // restore original headers
        bit<16> len_bytes = ((bit<16>)hdr.int_shim.len) << 2;
        if(hdr.ipv4.isValid()){
            hdr.ipv4.dscp = hdr.int_shim.dscp;
            hdr.ipv4.totalLen = hdr.ipv4.totalLen - len_bytes;
        } else {
            hdr.ipv6.traffic_class = hdr.int_shim.dscp;
            hdr.ipv6.payload_len = hdr.ipv6.payload_len - len_bytes;
        }


        if (hdr.udp.isValid()) {
            hdr.udp.len = hdr.udp.len - len_bytes;
        }

        hdr.int_data.setInvalid();

        // remove INT data added in INT sink
        hdr.int_switch_id.setInvalid();
        hdr.int_port_ids.setInvalid();
        hdr.int_ingress_tstamp.setInvalid();
        hdr.int_egress_tstamp.setInvalid();
        hdr.int_hop_latency.setInvalid();
        hdr.int_level2_port_ids.setInvalid();
        hdr.int_q_occupancy.setInvalid();
        hdr.int_egress_port_tx_util.setInvalid();

        // remove int data
        hdr.int_shim.setInvalid();
        hdr.int_header.setInvalid();

        //log_msg("cool");
    }

    apply {
        // INT sink must process only INT packets
        if (!hdr.int_header.isValid())
            return;

        if (standard_metadata.instance_type == 0 && meta.int_metadata.remove_int == 1) {
            // remove INT headers from a frame
            remove_sink_header();
        }
        if (standard_metadata.instance_type == 1) {
            // prepare an INT report for the INT collector
            Int_report.apply(hdr, meta, standard_metadata);
        }

    }
}
# 30 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/forward.p4" 1
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Damian Parniewicz, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

control Forward(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

    action send_to_cpu(bit<9> port) {
        standard_metadata.egress_spec = port;
    }

    action send_to_port(bit<9> port) {
        standard_metadata.egress_spec = port;
    }

    table tb_forward {
        actions = {
            send_to_cpu;
            send_to_port;
        }
        key = {
            hdr.ethernet.dstAddr: ternary;
        }
        size = 31;
    }

    apply {
        tb_forward.apply();
    }
}
# 31 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/port_forward.p4" 1
/*
 * Copyright 2020-2021 PSNC, FBK
 *
 * Author: Damian Parniewicz, Damu Ding
 *
 * Created in the GN4-3 project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


control PortForward(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

    action send(bit<9> port) {
        //standard_metadata.egress_port = port;
        standard_metadata.egress_spec = port;
    }
    // DAMU: Let's remove it
    /*action drop() {*/
        /*#ifdef BMV2*/
        /*// TODO mark_to_drop*/
        /*#elif TOFINO*/
        /*ig_dprsr_md.drop_ctl = 1;*/
        /*#endif*/
    /*}*/

    table tb_port_forward {
        actions = {
            send;
        }
        key = {
            standard_metadata.egress_port : exact;
        }
        size = 31;
    }

    apply {
        tb_port_forward.apply();
    }
}
# 32 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/srv6.p4" 1
/*

 */

control SRv6(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {


    // --- srv6_my_sid----------------------------------------------------------

    // Process the packet if the destination IP is the segemnt Id(sid) of this
    // device. This table will decrement the "segment left" field from the Srv6
    // header and set destination IP address to next segment.

    action srv6_end() {
        if(hdr.srv6h.isValid()){
            hdr.srv6h.segment_left = hdr.srv6h.segment_left - 1;
            hdr.ipv6.dst_addr = meta.next_srv6_sid;
        }
    }

    direct_counter(CounterType.packets_and_bytes) srv6_my_sid_table_counter;
    table srv6_my_sid {
      key = {
          hdr.ipv6.dst_addr: lpm;
      }
      actions = {
          srv6_end;
      }
      counters = srv6_my_sid_table_counter;
    }

    // --- srv6_transit --------------------------------------------------------

    // Inserts the SRv6 header to the IPv6 header of the packet based on the
    // destination IP address.


    action insert_srv6h_header(bit<8> num_segments) {
        hdr.srv6h.setValid();
        hdr.srv6h.next_hdr = hdr.ipv6.next_hdr;
        hdr.srv6h.hdr_ext_len = num_segments * 2;
        hdr.srv6h.routing_type = 4;
        hdr.srv6h.segment_left = num_segments - 1;
        hdr.srv6h.last_entry = num_segments - 1;
        hdr.srv6h.flags = 0;
        hdr.srv6h.tag = 0;
        hdr.ipv6.next_hdr = IP_PROTO_SRV6;
    }

    /*
       Single segment header doesn't make sense given PSP
       i.e. we will pop the SRv6 header when segments_left reaches 0
     */

    action srv6_t_insert_2(ipv6_addr_t s1, ipv6_addr_t s2) {
        hdr.ipv6.dst_addr = s1;
        hdr.ipv6.payload_len = hdr.ipv6.payload_len + 40;
        insert_srv6h_header(2);
        hdr.srv6_list[0].setValid();
        hdr.srv6_list[0].segment_id = s2;
        hdr.srv6_list[1].setValid();
        hdr.srv6_list[1].segment_id = s1;
    }

    action srv6_t_insert_3(ipv6_addr_t s1, ipv6_addr_t s2, ipv6_addr_t s3) {
        hdr.ipv6.dst_addr = s1;
        hdr.ipv6.payload_len = hdr.ipv6.payload_len + 56;
        insert_srv6h_header(3);
        hdr.srv6_list[0].setValid();
        hdr.srv6_list[0].segment_id = s3;
        hdr.srv6_list[1].setValid();
        hdr.srv6_list[1].segment_id = s2;
        hdr.srv6_list[2].setValid();
        hdr.srv6_list[2].segment_id = s1;
    }

    direct_counter(CounterType.packets_and_bytes) srv6_transit_table_counter;
    table srv6_transit {
      key = {
          hdr.ipv6.dst_addr: lpm;
      }
      actions = {
          srv6_t_insert_2;
          srv6_t_insert_3;
      }
      counters = srv6_transit_table_counter;
    }

    // Called directly in the apply block.
    action srv6_pop() {
      hdr.ipv6.next_hdr = hdr.srv6h.next_hdr;
      // SRv6 header is 8 bytes
      // SRv6 list entry is 16 bytes each
      // (((bit<16>)hdr.srv6h.last_entry + 1) * 16) + 8;
      bit<16> srv6h_size = (((bit<16>)hdr.srv6h.last_entry + 1) << 4) + 8;
      hdr.ipv6.payload_len = hdr.ipv6.payload_len - srv6h_size;

      hdr.srv6h.setInvalid();
      // Need to set MAX_HOPS headers invalid
      hdr.srv6_list[0].setInvalid();
      hdr.srv6_list[1].setInvalid();
      hdr.srv6_list[2].setInvalid();
    }

    apply {

        if (srv6_my_sid.apply().hit) {
        // PSP logic -- enabled for all packets
            if (hdr.srv6h.isValid() && hdr.srv6h.segment_left == 0) {
                srv6_pop();
            }
        } else {
            srv6_transit.apply();
        }
    }
}
# 33 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2
# 1 "/home/lchampagne/Documents/Test/int_v1.0/include/flowlet.p4" 1
/*

*/






control Flowlet(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

 //register<bit<ID_WIDTH>>(REGISTER_SIZE) flowlet_to_id;
    register<bit<48>>(8192) flowlet_time_stamp;

    action read_flowlet_registers(){
        bit<128> ip_src;
        bit<128> ip_dst;

     if (hdr.ipv4.isValid()){
      ip_src = (bit<128>) hdr.ipv4.srcAddr;
            ip_dst = (bit<128>) hdr.ipv4.dstAddr;
     } else {
      ip_src = hdr.ipv6.src_addr;
            ip_dst = hdr.ipv6.dst_addr;
     }

        //compute register index
        hash(meta.flowlet_register_index, HashAlgorithm.crc16,
            (bit<16>)0,
            { ip_src, ip_dst, meta.layer34_metadata.l4_src, meta.layer34_metadata.l4_dst, meta.layer34_metadata.l4_proto},
            (bit<14>)8192);

         //Read previous time stamp
        flowlet_time_stamp.read(meta.flowlet_last_stamp, (bit<32>)meta.flowlet_register_index);

        //Read previous flowlet id
        //flowlet_to_id.read(meta.flowlet_id, (bit<32>)meta.flowlet_register_index);

        //Update timestamp
        flowlet_time_stamp.write((bit<32>)meta.flowlet_register_index, standard_metadata.ingress_global_timestamp);
    }

    action update_path(){
       meta.update_path = 1;
    }

    // table used to activate flow monitoring for an egress port of the switch
    table tb_activate_flow_dest {
        actions = {
            NoAction;
        }
        key = {
            standard_metadata.egress_spec: exact;
        }
        size = 255;
    }

    apply {

        if (!tb_activate_flow_dest.apply().hit) return;

        meta.update_path = 0;

        @atomic {
            read_flowlet_registers();
            meta.flowlet_time_diff = standard_metadata.ingress_global_timestamp - meta.flowlet_last_stamp;

            log_msg("last time: {}", {meta.flowlet_last_stamp});

            //check if inter-packet gap is > FLOWLET_TIMEOUT
            if (meta.flowlet_time_diff > 48w200000){
                update_path();
            }
        }
    }
}
# 34 "/home/lchampagne/Documents/Test/int_v1.0/int.p4" 2

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t ig_intr_md) {


 action ipv4_forward (bit<48> dstAddr, bit<9> port) {
        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = dstAddr;

        ig_intr_md.egress_spec = port;
        //hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }

    table ipv4_lpm {
        key = {hdr.ipv4.dstAddr:lpm;}
        actions = {
            ipv4_forward;
            NoAction;
        }
        size=256;
        default_action=NoAction;
    }

    action drop() {
        mark_to_drop(ig_intr_md);
    }


    // *** L2 BRIDGING
    //
    // Here we define tables to forward packets based on their Ethernet
    // destination address. There are two types of L2 entries that we
    // need to support:
    //
    // 1. Unicast entries: which will be filled in by the control plane when the
    //    location (port) of new hosts is learned.
    // 2. Broadcast/multicast entries: used replicate NDP Neighbor Solicitation
    //    (NS) messages to all host-facing ports;
    //
    // For (2), unlike ARP messages in IPv4 which are broadcasted to Ethernet
    // destination address FF:FF:FF:FF:FF:FF, NDP messages are sent to special
    // Ethernet addresses specified by RFC2464. These addresses are prefixed
    // with 33:33 and the last four octets are the last four octets of the IPv6
    // destination multicast address. The most straightforward way of matching
    // on such IPv6 broadcast/multicast packets, without digging in the details
    // of RFC2464, is to use a ternary match on 33:33:**:**:**:**, where * means
    // "don't care".
    //
    // For this reason, our solution defines two tables. One that matches in an
    // exact fashion (easier to scale on switch ASIC memory) and one that uses
    // ternary matching (which requires more expensive TCAM memories, usually
    // much smaller).

    // --- l2_exact_table (for unicast entries) --------------------------------

    action set_egress_port(port_num_t port_num) {
        ig_intr_md.egress_spec = port_num;
    }

    table l2_exact_table {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            set_egress_port;
            drop;
            NoAction;
        }
        const default_action = NoAction;
        // The @name annotation is used here to provide a name to this table
        // counter, as it will be needed by the compiler to generate the
        // corresponding P4Info entity.
        @name("l2_exact_table_counter")
        counters = direct_counter(CounterType.packets_and_bytes);
    }

    // --- l2_ternary_table (for broadcast/multicast entries) ------------------

    action set_multicast_group(mcast_group_id_t gid) {
        // gid will be used by the Packet Replication Engine (PRE) in the
        // Traffic Manager--located right after the ingress pipeline, to
        // replicate a packet to multiple egress ports, specified by the control
        // plane by means of P4Runtime MulticastGroupEntry messages.

        if(hdr.ipv6.isValid()) hdr.ipv6.hop_limit = hdr.ipv6.hop_limit - 1;
        ig_intr_md.mcast_grp = gid;
        meta.is_multicast = true;
    }

    table l2_ternary_table {
        key = {
            hdr.ethernet.dstAddr: ternary;
        }
        actions = {
            set_multicast_group;
            @defaultonly NoAction;
        }
        const default_action = NoAction;
        @name("l2_ternary_table_counter")
        counters = direct_counter(CounterType.packets_and_bytes);
    }


    // --- ndp_reply_table -----------------------------------------------------

    action ndp_ns_to_na(mac_addr_t target_mac) {
        hdr.ethernet.srcAddr = target_mac;
        hdr.ethernet.dstAddr = IPV6_MCAST_01;
        ipv6_addr_t host_ipv6_tmp = hdr.ipv6.src_addr;
        hdr.ipv6.src_addr = hdr.ndp.target_ipv6_addr;
        hdr.ipv6.dst_addr = host_ipv6_tmp;
        hdr.ipv6.next_hdr = IP_PROTO_ICMPV6;
        hdr.icmpv6.type = ICMP6_TYPE_NA;
        hdr.ndp.flags = NDP_FLAG_ROUTER | NDP_FLAG_OVERRIDE;
        hdr.ndp.type = NDP_OPT_TARGET_LL_ADDR;
        hdr.ndp.length = 1;
        hdr.ndp.target_mac_addr = target_mac;
        ig_intr_md.egress_spec = ig_intr_md.ingress_port;
    }

    table ndp_reply_table {
        key = {
            hdr.ndp.target_ipv6_addr: exact;
        }
        actions = {
            ndp_ns_to_na;
        }
        @name("ndp_reply_table_counter")
        counters = direct_counter(CounterType.packets_and_bytes);
    }

    // --- my_station_table ---------------------------------------------------

    table my_station_table {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = { NoAction; }
        @name("my_station_table_counter")
        counters = direct_counter(CounterType.packets_and_bytes);
    }

    // --- routing_v6_table ----------------------------------------------------


    action ecmp_group(bit<14> ecmp_group_id, bit<16> num_nhops){
        hash(meta.ecmp_metadata.ecmp_hash,
        HashAlgorithm.crc16,
        (bit<1>)0,
        { hdr.ipv6.src_addr,
          hdr.ipv6.dst_addr,
          meta.layer34_metadata.l4_src,
          meta.layer34_metadata.l4_dst,
          hdr.ipv6.next_hdr},
        num_nhops);

        meta.ecmp_metadata.ecmp_group_id = ecmp_group_id;
    }

    action ipv6_forward (bit<48> dstAddr, bit<9> port) {
        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = dstAddr;

        ig_intr_md.egress_spec = port;
        //hdr.ipv6.hop_limit = hdr.ipv6.hop_limit - 1;
    }


    table ecmp_group_to_nhop {
        key = {
            meta.ecmp_metadata.ecmp_group_id: exact;
            meta.ecmp_metadata.ecmp_hash: exact;
        }
        actions = {
            drop;
            ipv6_forward;
        }
        size = 1024;
    }

    table ipv6_lpm {
        key = {hdr.ipv6.dst_addr:lpm;}
        actions = {
            ipv6_forward;
            ecmp_group;
            NoAction;
        }
        size=256;
        default_action=NoAction;
    }

    // *** ACL
    //
    // Provides ways to override a previous forwarding decision, for example
    // requiring that a packet is cloned/sent to the CPU, or dropped.
    //
    // We use this table to clone all NDP packets to the control plane, so to
    // enable host discovery. When the location of a new host is discovered, the
    // controller is expected to update the L2 and L3 tables with the
    // correspionding brinding and routing entries.

    action send_to_cpu() {
        ig_intr_md.egress_spec = 0;
    }

    action clone_to_cpu() {
        // Cloning is achieved by using a v1model-specific primitive. Here we
        // set the type of clone operation (ingress-to-egress pipeline), the
        // clone session ID (the CPU one), and the metadata fields we want to
        // preserve for the cloned packet replica.
        return;
        //clone3(CloneType.I2E, CPU_CLONE_SESSION_ID, { ig_intr_md.ingress_port });
    }

    table acl_table {
        key = {
            ig_intr_md.ingress_port: ternary;
            hdr.ethernet.dstAddr: ternary;
            hdr.ethernet.srcAddr: ternary;
            hdr.ethernet.etherType: ternary;
            meta.ip_proto: ternary;
            meta.icmp_type: ternary;
            meta.layer34_metadata.l4_src: ternary;
            meta.layer34_metadata.l4_dst: ternary;
        }
        actions = {
            send_to_cpu;
            clone_to_cpu;
            drop;
        }
        @name("acl_table_counter")
        counters = direct_counter(CounterType.packets_and_bytes);
    }

 apply {


        if (hdr.cpu_out.isValid()) {
            ig_intr_md.egress_spec = hdr.cpu_out.egress_port;
            hdr.cpu_out.setInvalid();
            exit;
        }

        bool do_l3_l2 = true;

        if (hdr.icmpv6.isValid() && hdr.icmpv6.type == ICMP6_TYPE_NS) {
            if (ndp_reply_table.apply().hit) {
                do_l3_l2 = false;
            }
        }

        if (do_l3_l2) {

            if (hdr.ipv4.isValid()) ipv4_lpm.apply();

            //if (hdr.ipv6.isValid() && my_station_table.apply().hit) {

            if (hdr.udp.isValid() || hdr.tcp.isValid()) {
                // in case of INT source port add main INT headers
                Int_source.apply(hdr, meta, ig_intr_md);
            }

            if (hdr.ipv6.isValid()){
                SRv6.apply(hdr, meta, ig_intr_md);
                switch (ipv6_lpm.apply().action_run){
                    ecmp_group: {
                        ecmp_group_to_nhop.apply();
                    }
                }
                if(hdr.ipv6.hop_limit == 0) { drop(); }
            }

            // L2 bridging logic. Apply the exact table first...
            if (!l2_exact_table.apply().hit) {
                // ...if an entry is NOT found, apply the ternary one in case
                // this is a multicast/broadcast NDP NS packet.
                l2_ternary_table.apply();
                if(meta.is_multicast && hdr.ipv6.hop_limit < 252){mark_to_drop(ig_intr_md);}//drop multicast packet
            }

            if (hdr.udp.isValid() || hdr.tcp.isValid()){
                // in case of sink node make packet clone I2E in order to create INT report
                // which will be send to INT reporting port
                Int_sink_config.apply(hdr, meta, ig_intr_md);
            }

            Flowlet.apply(hdr, meta, ig_intr_md);
        }

        // Lastly, apply the ACL table.
        acl_table.apply();
 }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t eg_intr_md) {
 apply {

        log_msg("Q depth: {}", {eg_intr_md.enq_qdepth});


        if (eg_intr_md.egress_port == 0) {
            hdr.cpu_in.setValid();
            hdr.cpu_in.ingress_port = eg_intr_md.ingress_port;
            exit;
        }

        // If this is a multicast packet (flag set by l2_ternary_table), make
        // sure we are not replicating the packet on the same port where it was
        // received. This is useful to avoid broadcasting NDP requests on the
        // ingress port.
        /*if(eg_intr_md.egress_port == 1 &&
           hdr.ipv6.isValid()){hdr.ipv6.hop_limit = 255;}//no router in the network therefore packet will be dropped if hop_limit different*/
        if (meta.is_multicast == true &&
            eg_intr_md.ingress_port == eg_intr_md.egress_port) {
            mark_to_drop(eg_intr_md);
        }

  Int_transit.apply(hdr, meta, eg_intr_md);
  // in case of the INT sink port remove INT headers
  // when frame duplicate on the INT report port then reformat frame into INT report frame
  Int_sink.apply(hdr, meta, eg_intr_md);

        if(hdr.tcp.isValid()) meta.tcpLen = hdr.ipv4.totalLen - (bit<16>)(hdr.ipv4.ihl)*4;
 }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
